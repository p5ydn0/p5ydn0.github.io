<!DOCTYPE html>
<!-- saved from url=(0099)file:///private/var/folders/jq/l66hzx9956qbmxs_990g1djh0000gn/T/mume2020317-90899-1qgy46k.c6lq.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>《大话数据结构》学习之6</title>
      
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="./《大话数据结构》学习之6_files/katex.min.css">
      
      

      
      
      
      
      
      
      

      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0">《大话数据结构》学习</h1>

<h3 class="mume-header" id="%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%AD%E6%A0%91">《大话数据结构》学习之六：树</h3>

<hr>
<h2 class="mume-header" id="6-%E6%A0%91">6. 树</h2>

<h3 class="mume-header" id="61-%E5%BC%80%E5%9C%BA%E7%99%BD">6.1. 开场白</h3>

<h3 class="mume-header" id="62-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">6.2. 树的定义</h3>

<p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n＞1 时，其余结点可分为 m（m＞0）个互不相交的有限集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_{1}, T_{2},...,T_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/114.png" alt=""></p>
<p>子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  和子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就是根结点 A 的子树。D、G、H、I 组成的树又是 B 为根结点的子树，E、J 组成的树是以 C 为根结点的子树。</p>
<p><img src="./《大话数据结构》学习之6_files/115.png" alt=""></p>
<p>树的定义还需要强调两点：</p>
<ol>
<li><code>n&gt;0</code> 时根结点是唯一的，不可能存在多个根结点。</li>
<li><code>m&gt;0</code>时，子树的个数没有限制，但它们一定是互不相交的。下图中的两个结构就不符合树的定义，因为它们都有相交的子树。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/116.png" alt=""></p>
<h4 class="mume-header" id="621-%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB">6.2.1. 结点分类</h4>

<p>树的结点包含一个数据元素及若干指向其子树的分支。<strong>结点拥有的子树数称为结点的度（Degree）。度为 0 的结点称为叶结点（Leaf）或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</strong> 下图所示的这棵树的度为 3。</p>
<p><img src="./《大话数据结构》学习之6_files/117.png" alt=""></p>
<h4 class="mume-header" id="622-%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB">6.2.2. 结点间关系</h4>

<p><strong>结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。</strong> 同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙。如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/118.png" alt=""></p>
<h4 class="mume-header" id="623-%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">6.2.3. 树的其他相关概念</h4>

<p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 l 层，则其子树就在第 l+1 层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/119.png" alt=""></p>
<p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>
<p><strong>森林（Forest）是 m(m≥0) 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。任何一棵树，删除了根结点就变成了森林。</strong></p>
<p>线性表与树的结构的对比：</p>
<p><img src="./《大话数据结构》学习之6_files/120.png" alt=""></p>
<h3 class="mume-header" id="63-%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">6.3. 树的抽象数据类型</h3>

<p>相对于线性结构，树的操作及完全不同了。这里给出一些基本和常用的操作。</p>
<pre data-role="codeBlock" data-info="C" class="language-c">ADT 树 <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
Data<span class="token operator">:</span>
      树是由一个根结点和若干棵子数构成<span class="token punctuation">.</span>树中结点具有相同数据类型及层次关系
 Operation<span class="token operator">:</span>
        <span class="token function">InitTree</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">:</span>构成空树T

        <span class="token function">DestroyTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">:</span>销毁树T

        <span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span>definition<span class="token punctuation">)</span><span class="token operator">:</span>按definition中给出的树的定义来构造树

        <span class="token function">ClearTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">:</span>若树T存在<span class="token punctuation">,</span>则将树T请为空树

        <span class="token function">TreeEmpty</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">:</span>若T为空树<span class="token punctuation">,</span>返回true<span class="token punctuation">,</span>否则返回false

        <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">:</span>返回T的深度

        <span class="token function">Root</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">:</span>返回T的根结点

        <span class="token function">Value</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>cur_e<span class="token punctuation">)</span><span class="token operator">:</span>cur_e是树T中一个结点<span class="token punctuation">,</span>返回此结点的值

        <span class="token function">Assign</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>cur_e<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token operator">:</span>给树T的结点cur_e赋值为value

        <span class="token function">Parent</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>cur_e<span class="token punctuation">)</span><span class="token operator">:</span>若cur_e是树T的非根结点<span class="token punctuation">,</span>返回它的双亲<span class="token punctuation">,</span>否则返回空

        <span class="token function">LeftChild</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>cur_e<span class="token punctuation">)</span><span class="token operator">:</span>若cur_e是树T的非叶节点<span class="token punctuation">,</span>则返回它的最左孩子<span class="token punctuation">,</span>否则返回空

        <span class="token function">RightSibling</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>cur_e<span class="token punctuation">)</span><span class="token operator">:</span>若cur_e有右兄弟<span class="token punctuation">,</span>则返回他的右兄弟<span class="token punctuation">,</span>否则返回空

        <span class="token function">InsertChild</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">,</span>i<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token operator">:</span>其中p指向树T的某个结点<span class="token punctuation">,</span>T为所指结点p的度加上<span class="token number">1</span><span class="token punctuation">,</span>非空树c与T
                               不相交<span class="token punctuation">,</span>操作结果为插入c为树T中p所指结点的第i棵子树
        <span class="token function">DeleteChile</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token operator">:</span>其中p指向树T的某个结点<span class="token punctuation">,</span>i为所指结点p的度<span class="token punctuation">,</span>操作结果为删除T中p所指结点的第i棵子树
endADT
</pre><h3 class="mume-header" id="64-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">6.4. 树的存储结构</h3>

<p>树中某个结点的孩子可以有多个，这就意味着，无论按何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系。</p>
<p>不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。这里介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。</p>
<h4 class="mume-header" id="641-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95">6.4.1. 双亲表示法</h4>

<p>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p>
<p><img src="./《大话数据结构》学习之6_files/121.png" alt=""></p>
<p>其中，data 是数据域，存储结点的数据信息；而 parent 是指针域，存储该结点的双亲在数组中的下标。</p>
<p>以下是双亲表示法的结点结构定义代码：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">//树的双亲表示法结点结构定义</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MAX_TREE_SIZE 100</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> TElemType<span class="token punctuation">;</span>   <span class="token comment">//树结点的数据类型,目前暂定义为整型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> PTNode   <span class="token comment">//结点结构</span>
<span class="token punctuation">{</span>
        TElemType data<span class="token punctuation">;</span>     <span class="token comment">//结点数据</span>
        <span class="token keyword">int</span> parent<span class="token punctuation">;</span>               <span class="token comment">//双亲位置</span>
<span class="token punctuation">}</span>PTNode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>                 <span class="token comment">//树结构</span>
<span class="token punctuation">{</span>
        PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//结点数组</span>
        <span class="token keyword">int</span> r<span class="token punctuation">,</span>n<span class="token punctuation">;</span>                     <span class="token comment">//根的位置和结点数</span>
<span class="token punctuation">}</span>PTree<span class="token punctuation">;</span>
</pre><p>由于根结点是没有双亲的,约定根结点的位置域设置为-1,这就意味着所有的结点都存在他的双亲结点。下图是树结构和该树的双亲表示：</p>
<p><img src="./《大话数据结构》学习之6_files/122.png" alt=""></p>
<p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，知道 parent 为 -1，表示找到了树结点的根。如果要知道结点的孩子是什么,就必须遍历整个结构才行。</p>
<p>这个有点麻烦，接下来进行下改进：</p>
<p>增加一个结点最左边孩子的域，叫长子域，如果没有孩子的结点，这个长子域就设置为 -1。如下图：</p>
<p><img src="./《大话数据结构》学习之6_files/123.png" alt=""></p>
<p>如果我们关注各兄弟之间的关系，则可：每一个结点如果它存在右兄弟，则记录下右兄弟的下标，如果右兄弟不存在,则赋值为 -1。如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/124.png" alt=""></p>
<p>存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。</p>
<h4 class="mume-header" id="642-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95">6.4.2. 孩子表示法</h4>

<p>由于树中每个结点可能有多棵子树，可以考虑多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p>
<p><strong>方案一：</strong></p>
<p>指针域的个数等于树的度（树的度是各个结点度的最大值）。其结构如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/125.png" alt=""></p>
<p>其中 data 是数据域，child1 到 childd 是指针域，用来指向该结点的孩子结点。</p>
<p>对于下图中的树来说，树的度是 3，所以指针域的个数是 3，这种实现方法如下下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/126.png" alt=""></p>
<p><img src="./《大话数据结构》学习之6_files/127.png" alt=""></p>
<p>这种方法对于树中各结点的度相差很大时,显然很浪费空间,因为有很多的结点指针域都是空的.如果树的各结点度相差很小时,开辟空间被充分利用了,这时缺点变优点。</p>
<p>既然很多指针域都可能为空，为什么不按需分配呢？于是就有了第二种方案。</p>
<p><strong>方案二：</strong></p>
<p>每个结点指针域的个数等于该结点的度，取一个位置来储存结点指针域的个数。其结构如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/128.png" alt=""></p>
<p>对上面那棵树来说，这种实现如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/129.png" alt=""></p>
<p>这种方法克服了浪费空间的缺点，对空间利用率提高，但由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上会带来时间上的损耗。</p>
<p><strong>孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。</strong> 如下下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/126.png" alt=""></p>
<p><img src="./《大话数据结构》学习之6_files/130.png" alt=""></p>
<p>为此设置了两种结点结构：一个是孩子链表的孩子结点：</p>
<p><img src="./《大话数据结构》学习之6_files/131.png" alt=""></p>
<p>另一个是表头数组的表头结点：</p>
<p><img src="./《大话数据结构》学习之6_files/132.png" alt=""></p>
<p>以下是孩子表示法的结构定义代码：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/*数的孩子表示法结构定义*/</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MAX_TREE_SIZE 100</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> TElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> CTNode <span class="token comment">//孩子结点</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> child<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> CTNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">*</span>ChildPtr<span class="token punctuation">;</span>
<span class="token keyword">typedef</span>  <span class="token keyword">struct</span> <span class="token comment">//表头结构</span>
<span class="token punctuation">{</span>
    TElemType data<span class="token punctuation">;</span>
    ChildPtr firstchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>CTBox<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token comment">//树结构</span>
<span class="token punctuation">{</span>
    CTBox nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//结点数组</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> n<span class="token punctuation">;</span>   <span class="token comment">//根的位置和结点数</span>
<span class="token punctuation">}</span>CTree<span class="token punctuation">;</span>
</pre><p>这样的结构对于要查找某个结点的某个孩子，或者找某结点的兄弟，只需要查找这个结点的孩子单链表即可。但要知道某结点的双亲是谁，比较麻烦，需要遍历整棵树才行。</p>
<p><strong>双亲孩子表示法：</strong>（是孩子表示法的改进）</p>
<p><img src="./《大话数据结构》学习之6_files/133.png" alt=""></p>
<h4 class="mume-header" id="643-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95">6.4.3. 孩子兄弟表示法</h4>

<p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的，因此，设置两个指针，分别指向该结点的第一个孩子和此结点的兄弟。结构如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/134.png" alt=""></p>
<p>结构定义代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 树的孩子兄弟表示法结构定义 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> CSNode
<span class="token punctuation">{</span>
    TElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> CSNode <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>rightsib<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span>
</pre><p>这种方法的示意图如下：</p>
<p><img src="./《大话数据结构》学习之6_files/135.png" alt=""></p>
<p>这种表示法，查找某个结点的某个孩子只需要通过 fistchild 找到此结点的长子，再通过长子结点的 rightsib 找到它的二弟，接着一直下去，直到找到具体的孩子。当然，如果想要找到某个结点的双亲，这个表示法也是有缺陷的。如果真有必要，完全可以再增加一个 parent 指针域来解决快速查找双亲的问题。</p>
<p>这个表示法的最大好处是把一棵复杂的树变成了一棵二叉树。如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/136.png" alt=""></p>
<p>这样就可以充分利用二叉树的特性和算法来处理这棵树了。</p>
<h3 class="mume-header" id="65-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">6.5. 二叉树的定义</h3>

<p>二叉树是 n(n&gt;=0) 个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。</p>
<p><img src="./《大话数据结构》学习之6_files/137.png" alt=""></p>
<h4 class="mume-header" id="651-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E7%82%B9">6.5.1. 二叉树特点</h4>

<p>二叉树的特点有：</p>
<ul>
<li>每个结点最多有两颗子树，所以二叉树不存在度大于 2 的结点；</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒；</li>
<li>即使树中某结点只有一颗子树，也要区分左子树和右子树的；它们是不同的二叉树。</li>
</ul>
<p><img src="./《大话数据结构》学习之6_files/138.png" alt=""></p>
<p>二叉树的五种基本形态：</p>
<ol>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>树既有左子树也有右子树</li>
</ol>
<h4 class="mume-header" id="652-%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91">6.5.2. 特殊二叉树</h4>

<ol>
<li>斜树</li>
</ol>
<p>斜树一定是斜的，所有的结点都只有左子树的二叉树叫左斜树。所有的二叉树只有右子数的树叉树叫右斜树。两者统称为斜树。斜树每一层都只有一个结点，结点的个数跟二叉树的深度相同。</p>
<p><img src="./《大话数据结构》学习之6_files/139.png" alt=""></p>
<p>线性表就是特殊的二叉树。</p>
<ol start="2">
<li>满二叉树</li>
</ol>
<p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
<p><img src="./《大话数据结构》学习之6_files/140.png" alt=""></p>
<p>满二叉树的特点:</p>
<ol>
<li>
<p>叶子只能出现在最下一层，出现在其他层就不可能达到平衡；</p>
</li>
<li>
<p>非叶子结点的度一定是 2；</p>
</li>
<li>
<p>在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。</p>
</li>
<li>
<p>完全二叉树</p>
</li>
</ol>
<p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i(1&lt;= i&lt;=n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树树完全二叉树。</p>
<p><img src="./《大话数据结构》学习之6_files/141.png" alt=""></p>
<p>尽管不是满二叉树，但是编号是连续的，所以它是完全二叉树。</p>
<p><img src="./《大话数据结构》学习之6_files/142.png" alt=""></p>
<p>满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树。</p>
<p>完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。关键词是按层序编号，树 1 因为 5 结点没有左子树，却有右子树，使得按层序编号的第 10 个编号空档。树 2 由于 3 结点没有子树，使得 6、7 编号的位置空档。树 3 因为 5 编号下没有子树造成第 10 和第 11 位置空档。</p>
<p><img src="./《大话数据结构》学习之6_files/143.png" alt=""></p>
<p>完全二叉树的特点:</p>
<ol>
<li>叶子结点只能出现在最下两层；</li>
<li>最下层的叶子一定集中在左部连续位置；</li>
<li>倒数两层，若有叶子结点，一定都在右部连续位置；</li>
<li>若结点度为 1,则该结点只有左孩子，即不存在只有右子树的情况；</li>
<li>同样结点树的二叉树,完全二叉树的深度最小。</li>
</ol>
<p>从上面的例子，也给了我们一个判断某二叉树是否是完全二叉树的办法，那就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不是二叉树，否则就是。</p>
<h3 class="mume-header" id="66-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">6.6. 二叉树的性质</h3>

<ul>
<li>性质 1：在二叉树的第i层上至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点(i&gt;=1)。</li>
</ul>
<p><img src="./《大话数据结构》学习之6_files/144.png" alt=""></p>
<ul>
<li>性质 2：深度为 k 的二叉树至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点(k&gt;=1)。</li>
</ul>
<p><img src="./《大话数据结构》学习之6_files/145.png" alt=""></p>
<ul>
<li>性质 3：对任何一棵二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，如果其终端结点数(叶子结点数)为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，度为 2 的结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_{0}=n_{2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
<p><img src="./《大话数据结构》学习之6_files/146.png" alt=""></p>
<p>一棵二叉树中，除了叶子结点外，剩下的就是度为 1 或 2 的结点树了，设为度为 1 的结点数。则树的总结点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n=n_{0}+n_{1}+n_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<ul>
<li>
<p>性质 4：具有 n 个结点的完全二叉树的深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo fence="true">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left\lfloor\log _{2} n\right\rfloor+ 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⌊</mo><mtext>&nbsp;</mtext><mi>x</mi><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\ x \right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>表示不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最大整数）</p>
</li>
<li>
<p>性质 5：具有 n 个结点的完全二叉树(其深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo fence="true">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left\lfloor\log _{2} n\right\rfloor+ 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)的结点按层序编号(从第 1 层到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo fence="true">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left\lfloor\log _{2} n\right\rfloor+ 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 层，每层从左到右)，对任一结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1 \leq i \leq n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 有：</p>
</li>
</ul>
<ol>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 是二叉树的根，无双亲；如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则双亲是结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⌊</mo><mtext>&nbsp;</mtext><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\ i/2 \right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mspace">&nbsp;</span><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 无左孩子（结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 为叶子结点）；否则其左孩子是结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span></span></span></span>。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i+1&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 无右孩子；否则其右孩子是结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ol>
<p><strong>更多内容（如例子）详见书籍。</strong></p>
<h3 class="mume-header" id="67-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">6.7. 二叉树的存储结构</h3>

<h4 class="mume-header" id="671-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">6.7.1. 二叉树顺序存储结构</h4>

<p>前面我们已经谈到了树的存储结构，并且谈到顺序存储对树这种一对多的关系结构实现起来是比较困难的。但是二叉树是一种特殊的树，由于它的特殊性，使得用顺序存储结构也可以实现。</p>
<p>二叉树的顺序结构是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系。</p>
<p>先看完全二叉树的顺序存储；如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/147.png" alt=""></p>
<p>将这棵二叉树存入到数组中，相应的下标对应其同样的位置；如下图所示：</p>
<p><img src="./《大话数据结构》学习之6_files/148.png" alt=""></p>
<p>完全二叉树存入到数组中，相应的下标对应其同样的位置，一般的二叉树层序编号不能反映逻辑关系，但可以将其按完全二叉树编号，把不存在的结点设置为"^"。</p>
<p><img src="./《大话数据结构》学习之6_files/149.png" alt=""></p>
<p>考虑一种极端的情况，一棵深度为 k 的右斜树，它只有 k 个结点，却需要分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个存储单元，会造成对空间的极度浪费，所以顺序结构一般只用于完全二叉树。</p>
<p><img src="./《大话数据结构》学习之6_files/150.png" alt=""></p>
<h4 class="mume-header" id="672-%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8">6.7.2. 二叉链表</h4>

<p>二叉树每个结点最多有两个孩子，设计一个数据域和两个指针域，这样的链表为二叉链表。</p>
<p><img src="./《大话数据结构》学习之6_files/151.png" alt=""></p>
<p>二叉链表的结点结构定义代码：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 二叉树的二叉链表结点结构定义 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiTNode        <span class="token comment">/* 结点结构 */</span>
<span class="token punctuation">{</span>
    TElemType data<span class="token punctuation">;</span>           <span class="token comment">/* 结点数据 */</span>
    <span class="token keyword">struct</span> BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">/* 左右孩子指针 */</span>
<span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</pre><p>结构示意图如图：</p>
<p><img src="./《大话数据结构》学习之6_files/152.png" alt=""></p>
<p>就如同树的存储结构中讨论的一样，如果需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。</p>
<h3 class="mume-header" id="68%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91">6.8.遍历二叉树</h3>

<h4 class="mume-header" id="681-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86">6.8.1. 二叉树遍历原理</h4>

<p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得某个结点被访问一次且仅被访问一次。</p>
<p>这里有两个关键词：访问和次序。</p>
<p>访问其实是要根据实际的需要来确定具体做什么，比如对毎个结点进行相关计算，输出打印等，它算作是一个抽象操作。在这里我们可以简单地假定就是输出结点的数据信息。</p>
<p>二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。由于选择方式的不同，遍历的次序就完全不同了。</p>
<h4 class="mume-header" id="682-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95">6.8.2. 二叉树遍历方法</h4>

<ol>
<li>前序遍历</li>
</ol>
<p>若二叉树为空，则空操作返回，否则：</p>
<ol>
<li>先访问根结点；</li>
<li>前序遍历左子树；</li>
<li>前序遍历右子树。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/153.png" alt=""></p>
<p>遍历的顺序为：ABDGHCEIF。</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/*二叉树的前序遍历递归算法*/</span>
<span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token comment">//若树为空，返回为空</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//显示结点数据，可以更改为其它对结点操作</span>
    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//再先序遍历左子树</span>
    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//最后先序遍历右子树</span>
<span class="token punctuation">}</span>
</pre><ol start="2">
<li>中序遍历</li>
</ol>
<p>若树为空，则空操作返回，否则：</p>
<ol>
<li>从根结点开始(注意不是先访问根结点)；</li>
<li>中序遍历根结点的左子树，然后是访问根结点；</li>
<li>中序遍历右子树。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/154.png" alt=""></p>
<p>遍历的顺序为：GDHBAEICF。</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/*二叉树的中序遍历递归算法*/</span>
<span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//中序遍历左子树</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//显示结点数据，能够更改为其它对结点操作</span>
    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//最后中序遍历右子树</span>
<span class="token punctuation">}</span>
</pre><ol start="3">
<li>后序遍历</li>
</ol>
<p>若树为空，则空操作返回，否则：</p>
<ol>
<li>从左到右先叶子后结点的方式遍历访问左右子树；</li>
<li>最后是访问根结点。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/155.png" alt=""></p>
<p>遍历的顺序为：GHDBIEFCA。</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/*二叉树的后序遍历递归算法*/</span>
<span class="token keyword">void</span> <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
   <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先后序遍历左子树</span>
   <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//再后序遍历右子树</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//显示结点数据。能够更改为其它对结点操作</span>
<span class="token punctuation">}</span>
</pre><ol start="4">
<li>层序遍历</li>
</ol>
<p>若树为空,则空操作返回，否则：</p>
<ol>
<li>从树的第一层，也就是根结点开始访问；</li>
<li>从上而下逐层遍历；</li>
<li>在同一层中，按从左到右的顺序对结点逐个访问。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/156.png" alt=""></p>
<p>遍历的顺序为：ABCDEFGHI。</p>
<h4 class="mume-header" id="683-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">6.8.3. 前序遍历算法</h4>

<p>更多内容详见书籍。</p>
<h4 class="mume-header" id="684-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">6.8.4. 中序遍历算法</h4>

<p>更多内容详见书籍。</p>
<h4 class="mume-header" id="685-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">6.8.5. 后序遍历算法</h4>

<p>更多内容详见书籍。</p>
<h4 class="mume-header" id="686-%E6%8E%A8%E5%AF%BC%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C">6.8.6. 推导遍历结果</h4>

<p>更多内容详见书籍。</p>
<h3 class="mume-header" id="69-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B">6.9. 二叉树的建立</h3>

<p>对于一颗普通的二叉树，将二叉树中每一个结点的空指针引出一个虚结点，其值为一特定值，比方"#"。处理后的二叉树为原二叉树的扩展二叉树，扩展二叉树能够通过一个"前序"或"中序"或"后序"遍历序列确定一颗二叉树。</p>
<p><img src="./《大话数据结构》学习之6_files/157.png" alt=""></p>
<p>前序遍历序列为：AB#D##C##。</p>
<p>实现的算法如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/*按前序输入而二叉树中借点的值(一个字符)*/</span>
<span class="token comment">/*#表示空树，构造二叉链表表示二叉树T*/</span>
<span class="token keyword">void</span> <span class="token function">CreateBitree</span><span class="token punctuation">(</span>Bitree <span class="token operator">*</span>T<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TElemType ch<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//输入结点数据字符</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">)</span>
            <span class="token operator">*</span>T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
     <span class="token punctuation">{</span>
            <span class="token operator">*</span>T<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//为数据为字符的结点在内存中分配空间</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>T<span class="token punctuation">)</span>                                                    <span class="token comment">//假设分配未成功则异常结束(内存溢出)</span>
                    <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>                                    <span class="token comment">//生成根结点</span>
            <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//构造左子树</span>
            <span class="token function">CreateBiiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//构造右子树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>其实建立二叉树，也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。所以理解了前面的遍历的话，对于这段代码就不难了。</p>
<p>当然，你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更改。</p>
<h3 class="mume-header" id="610-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">6.10. 线索二叉树</h3>

<h4 class="mume-header" id="6101-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8E%9F%E7%90%86">6.10.1. 线索二叉树原理</h4>

<p>一个有 n 个结点的二叉链表。每一个结点有指向左右孩子的两个指针域，一共是 2n 个指针域。n 个结点的二叉树一共同拥有 n-1 条分支线(根结点无前驱)，存在 2n-(n-1)=n+1 个空指针域。这些空间不存储任何事物，白白浪费着内存资源。</p>
<p><img src="./《大话数据结构》学习之6_files/158.png" alt=""></p>
<p>另一方面，我们在做遍历之后，我们就可以知道任意一个结点它的前驱和后继是哪一个。但这是建立在已经遍历过的基础之上的。为什么不考虑在创建时就记住这些前驱和后继呢，那将是多大的时间上的节省。</p>
<p>综合上述两个角度的分析，我们考虑线索二叉树。</p>
<p>将指向前驱和后驱的指针称为线索，加上线索的二叉链表则称为线索链表；加上线索的二叉树称为线索二叉树(Threaded Binary Tree)。</p>
<p>中序遍历后，将所有的空指针域中的 rchild，改为指向它的后继结点。通过指针知道 H 的后继是 D（①），I 的后继是 B（②），J 的后继是 E（③），E 的后继是 A（④），F 的后继是 C（⑤），G 的后继因为不存在而指向 NULL（⑥）。此时共有 6 个空指针域被利用。</p>
<p><img src="./《大话数据结构》学习之6_files/159.png" alt=""></p>
<p>将这棵二叉树的所有空指针域中的 lchild，改为指向当前结点的前驱。H 的前驱是 NULL（①），I 的前驱是 D（②），J 的前驱是 B（③），F 的前驱是 A（④），G 的前驱是 C（⑤）。一共 5 个空指针域被利用，正好和上面的后继加起来是 11 个。</p>
<p><img src="./《大话数据结构》学习之6_files/160.png" alt=""></p>
<p>线索二叉树，等于是把一棵二叉树转变成了一个双向链表，对插入删除结点、查找某个结点都带来了方便。</p>
<p>对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。</p>
<p><img src="./《大话数据结构》学习之6_files/161.png" alt=""></p>
<p>上图中，空心箭头实线为前驱，虚线黑箭头为后继。</p>
<p>不过又有一个新的问题出现，就是我们如何知道某一结点的 lchild 是指向它的左孩子还是指向前驱？rchild 是指向右孩子还是指向后继？因此，我们在每个结点再增设两个标志域 ltag 和 rtag，ltag 和 rtag 只是存放 0 或 1 数字的布尔型变量，占用的内存空间要小于像 lchild 和 rchild 的指针变量。</p>
<p><img src="./《大话数据结构》学习之6_files/162.png" alt=""></p>
<p>其中：</p>
<ul>
<li>ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱；</li>
<li>rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继。</li>
</ul>
<p>所以可以修改为：</p>
<p><img src="./《大话数据结构》学习之6_files/163.png" alt=""></p>
<h4 class="mume-header" id="6102-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0">6.10.2. 线索二叉树结构实现</h4>

<p>二叉树的线索存储结构定义代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token keyword">typedef</span> eum <span class="token punctuation">{</span>Link<span class="token punctuation">,</span>Thread<span class="token punctuation">}</span> PointerTag<span class="token punctuation">;</span>  <span class="token comment">/*二叉树的二叉线索存储结构定义*/</span>
                                       <span class="token comment">/*Link==0表示指向左右孩子指针*/</span>
                                       <span class="token comment">/*Thread==1表示指向前驱或后驱的线索*/</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiThrNode               <span class="token comment">/*二叉线索存储结点结构*/</span>
<span class="token punctuation">{</span>
    TElemType  data<span class="token punctuation">;</span>                   <span class="token comment">//数据域：结点数据</span>
    <span class="token keyword">struct</span> BiThrNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">//指针域：左右孩子指针</span>
    PointerTag   LTag<span class="token punctuation">;</span>
    PointerTag   RTag<span class="token punctuation">;</span>                 <span class="token comment">//左右标志</span>
<span class="token punctuation">}</span>BiThrNode<span class="token punctuation">,</span><span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span>
</pre><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。因为前驱和后继的信息只有在遍历该二叉树时才干得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。</p>
<p>中序遍历线索化的递归函数代码例如以下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c">BiThrTree pre<span class="token punctuation">;</span>    <span class="token comment">//全局变量。始终指向刚刚訪问过的结点</span>
<span class="token comment">/*中序遍历进行中序线索化*/</span>
 <span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BitThrTree p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//递归左子树线索化</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span>                    <span class="token comment">//结点无左孩子</span>
        <span class="token punctuation">{</span>
            p<span class="token operator">-&gt;</span>LTag<span class="token operator">=</span>Thread<span class="token punctuation">;</span>        <span class="token comment">//前驱线索：将结点左指针标志置1，说明左指针指向该结点的前驱</span>
            p<span class="token operator">-&gt;</span>lchild<span class="token operator">=</span>pre<span class="token punctuation">;</span>                <span class="token comment">//左孩子指针指向前驱</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span>                <span class="token comment">//前驱没有右孩子</span>
        <span class="token punctuation">{</span>
            pre<span class="token operator">-&gt;</span>RTag<span class="token operator">=</span>Thread<span class="token punctuation">;</span>    <span class="token comment">//后继线索</span>
            pre<span class="token operator">-</span>rchild<span class="token operator">=</span>p<span class="token punctuation">;</span>                <span class="token comment">//前驱右孩子指针指向后继(当前结点p)</span>
        <span class="token punctuation">}</span>
        pre<span class="token operator">=</span>p<span class="token punctuation">;</span>                            <span class="token comment">//保持pre指向p的前驱</span>
        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//递归右子树线索化</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p><strong>源码分析见书籍。</strong></p>
<p>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。</p>
<p>和双向链表结构一样，在线索链表上加入一个头结点，并令其 lchild 域的指针指向二叉树的根结点（图中的 ①）。其 rchild 域的指针指向中序遍历时訪问的最后一个结点（图中的 ②）。令二叉树中序序列中的第一个结点的 lchild 域指针和最后一个结点的 rchild 域的指针均指向头结点（图中的 ③ 和 ④。这样就创建了一个双向线索链表。优点是既能够从第一个结点起顺后继进行遍历。也能够从最后一个结点起顺前驱进行遍历。</p>
<p><img src="./《大话数据结构》学习之6_files/164.png" alt=""></p>
<p>遍历的代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点*/</span>
<span class="token comment">/*    中序遍历二叉线索链表表示的二叉树T，时间复杂度为O(n)*/</span>
Status <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>BiThTree T<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BiThrTree p<span class="token punctuation">;</span>
     p<span class="token operator">=</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>    <span class="token comment">//p指向根结点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> T<span class="token punctuation">)</span>    <span class="token comment">//空树或遍历结束时。p==T</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>LTag<span class="token operator">==</span>Link<span class="token punctuation">)</span>    <span class="token comment">//当LTag==0时循环到中序序列第一个结点</span>
                p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>
         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//显示结点数据，能够更改为其它对结点操作</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>RTag <span class="token operator">==</span> Thread <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>rchild <span class="token operator">!=</span>T<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>        <span class="token comment">//p进至其右子树根</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><strong>源码分析见书籍。</strong></p>
<p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</strong></p>
<h3 class="mume-header" id="611-%E6%A0%91-%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2">6.11. 树、森林与二叉树的转换</h3>

<h4 class="mume-header" id="6111-%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91">6.11.1. 树转换为二叉树</h4>

<p>将树转换为二叉树的步骤如下：</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。<strong>注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</strong></li>
</ol>
<p>如下图，一棵树经过三个步骤转换为一颗二叉树。初学者容易犯的错误是层次调整时弄错左右孩子的关系。图中 F、G 本都是树结点 B 的孩子，是结点 E 的兄弟，转换后，F 就是二叉树结点 E 的右孩子，G 是二叉树结点 F 的右孩子。</p>
<p><img src="./《大话数据结构》学习之6_files/165.png" alt=""></p>
<h4 class="mume-header" id="6112-%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91">6.11.2. 森林转换为二叉树</h4>

<p>森林是由若干棵树组成的，可以理解为森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作：</p>
<ol>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/166.png" alt=""></p>
<h4 class="mume-header" id="6113-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91">6.11.3. 二叉树转换为树</h4>

<p>二叉树转换为树是树转换为二叉树的逆过程步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的 n 个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/167.png" alt=""></p>
<h4 class="mume-header" id="6114-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97">6.11.4. 二叉树转换为森林</h4>

<p>判断一棵二叉树能够转换成一棵树还是森林，看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p>
<p>步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/168.png" alt=""></p>
<h4 class="mume-header" id="6115-%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86">6.11.5. 树与森林的遍历</h4>

<p>树的遍历分为两种方式：</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
</ol>
<p>如下图，右下方的树先根遍历序列为 ABEFCDG，后根遍历序列为 EFBCGDA。</p>
<p><img src="./《大话数据结构》学习之6_files/169.png" alt=""></p>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如下面三棵树的森林，前序遍历序列的结果就是 ABCDEFGHJI。</li>
<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如下面三棵树的森林，后序遍历序列的结果就是 BCDAFEJHIG。</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/170.png" alt=""></p>
<p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p>
<p><img src="./《大话数据结构》学习之6_files/171.png" alt=""></p>
<p>当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。这其实也就证实，我们找到了对树和森林这种复杂问题的简单解决办法。</p>
<h3 class="mume-header" id="612-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8">6.12. 赫夫曼树及其应用</h3>

<h4 class="mume-header" id="6121-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">6.12.1. 赫夫曼树</h4>

<p>假设现在要判断某个班某个学生成绩的等级，简单的可能会直接写出如下的代码：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">60</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
    b<span class="token operator">=</span><span class="token string">"不及格"</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">70</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
    b<span class="token operator">=</span><span class="token string">"及格"</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">80</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
    b<span class="token operator">=</span><span class="token string">"中等"</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">90</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
    b<span class="token operator">=</span><span class="token string">"良好"</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    b<span class="token operator">=</span><span class="token string">"优秀"</span><span class="token punctuation">;</span>
</pre><p>上述代码粗看没什么问题，但实际上（很大可能）是有效率问题的。将其用二叉树表示出来如下：</p>
<p><img src="./《大话数据结构》学习之6_files/172.png" alt=""></p>
<p>如果在实际的学习生活中，学生成绩的分布如下图：</p>
<p><img src="./《大话数据结构》学习之6_files/173.png" alt=""></p>
<p>那么 70 分以上大约占总数 80% 的成绩都需要经过 3 次以上的判断才可以得到结果，这显然不合理。</p>
<p>有没有好一些的办法？仔细发现，中等成绩（70～79）比例最高，其次是良好成绩，不及格的所占比例最少。把上面的图重新进行分配改成下图：</p>
<p><img src="./《大话数据结构》学习之6_files/174.png" alt=""></p>
<p>从图中感觉，效率应该高一些了。</p>
<h4 class="mume-header" id="6122-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86">6.12.2. 赫夫曼树定义与原理</h4>

<p>我们先把这两棵二叉树简化成叶子结点带权的二叉树，如下图所示。其中 A 表示不及格、B 表示及格、C 表示中等、D 表示良好、E 表示优秀。每个叶子的分支线上的数字就是五级分制的成绩所占的比例。</p>
<p><img src="./《大话数据结构》学习之6_files/175.png" alt=""></p>
<p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</p>
<p>树的路径长度就是从树根到每一结点的路径长度之和。</p>
<p>上图中，二叉树a 中，根结点到结点 D 的路径长度就为 4，二叉树b 中根结点到结点 D 的路径长度为 2。二叉树a 的树路径长度就为 1+1+2+2+3+3+4+4=20。二叉树b 的树路径长度就为 1+2+3+3+2+1+2+2=16。</p>
<p>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中<strong>所有叶子结点</strong>的带权路径长度之和。假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mo stretchy="false">[</mo></msub><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{w_{1},w_{2},...,w_[n]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></span>，构造一棵有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个叶子结点的二叉树，每个叶子结点带权 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，每个叶子的路径长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">l_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则其中带权路径长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">WPL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span></span></span></span> 最小的二叉树称做赫夫曼树(最优二叉树)。</p>
<p>二叉树a 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><mn>5</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>15</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>40</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>30</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>10</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>315</mn></mrow><annotation encoding="application/x-tex">WPL=5×1+15×2+40×3+30×4+10×4=315</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span></span></span></span>。</p>
<p>二叉树b 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><mn>5</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>15</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>40</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>30</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>10</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>220</mn></mrow><annotation encoding="application/x-tex">WPL=5×3+15×3+40×2+30×2+10×2=220</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</p>
<hr>
<p><strong>上述内容需要注意的点是：</strong> 树的路径长度是树根到<strong>每一结点</strong>的路径长度之和，而树的带权路径长度是<strong>所有叶子结点</strong>到树根之间的带权长度；仅是叶子结点而不是所有结点。</p>
<p><strong>另一个点是；</strong> 之所以树的带权路径只考虑树的叶子结点，可以结合前面学生成绩的例子来理解下；因为实际应用中可能关心的只是树根到每个叶子结点的距离，而不是所有的结点。这个知道以后，带权路径中所带的“权”也只是叶子结点带权也就很容易理解了；因为主要是关心到叶子结点。</p>
<hr>
<p>这样的结果意味着什么呢？如果我们现在有 10000 各学生的百分制成绩需要计算五级分制成绩，用二叉树a 的判断方法，需要做 31500 次比较，而二叉树b 的判断方法只需要 22000 次比较；效率大大提高。</p>
<p><strong>构造赫尔曼树：</strong></p>
<ol>
<li>
<p>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</p>
</li>
<li>
<p>取头两个最小权值的结点作为一个新节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的两个子结点，相对较小的是左孩子，这里就是 A 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的左孩子，E 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的右孩子，新结点的权值为两个叶子权值的和 5+10=15。</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/176.png" alt=""></p>
<ol start="3">
<li>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 替换 A 与 E，插入有序序列中，保持从小到大排列。即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>15，B15，D30，C40。</p>
</li>
<li>
<p>重复步骤 2。将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 B 作为一个新节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的两个子结点。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的权值=15+15=30。</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/177.png" alt=""></p>
<ol start="5">
<li>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 替换 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 B，插入有序序列中，保持从小到大排列。即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>30，D30，C40。</p>
</li>
<li>
<p>重复步骤 2。将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 D 作为一个新节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的两个子结点。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的权值=30+30=60。</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/178.png" alt=""></p>
<ol start="7">
<li>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 替换 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 D，插入有序序列中，保持从小到大排列。即：C40，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>60。</p>
</li>
<li>
<p>重复步骤 2。将 C 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作为一个新节点 T 的两个子结点，由于 T 即是根结点，完成赫夫曼树的构造。</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之6_files/179.png" alt=""></p>
<p>带权路径长度 WPL=40×1+30×2+15×3+10×4+5×4=205。</p>
<p><strong>构造赫夫曼树的赫夫曼算法描述：</strong></p>
<ol>
<li>根据给定的 n 个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{w_{1},w_{2},...,w_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>构成 n 棵二叉树的集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow></mrow><annotation encoding="application/x-tex">F={T_{1},T_{2},...,T_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，其中每棵二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中只有一个带权为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 根结点，其左右子树均为空。</li>
<li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li>
<li>重复 2 和 3 步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。</li>
</ol>
<h4 class="mume-header" id="6123-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">6.12.3. 赫夫曼编码</h4>

<p>赫尔曼可以被应用在数据传输的优化问题中。</p>
<p>假如要传输的文字内容为“BADCADFEED”，相应的二进制数据表示如下：</p>
<p><img src="./《大话数据结构》学习之6_files/180.png" alt=""></p>
<p>这样真正传输的数据就是编码后的“001000011010000011101100100011”。</p>
<p>现在假设六个字母的频率为 A 27，B 8，C 15，D15，E 30，F 5，合起来正好是 100%。完全可以重新按照赫夫曼树来规划它们。</p>
<p><img src="./《大话数据结构》学习之6_files/181.png" alt=""></p>
<p>左图为构造赫夫曼树过程的权值显示。右图为将权值左分支改为 0，右分支改为 1 的赫夫曼树。</p>
<p>此时，对这六个字母用其从树根到叶子所经过路径的 0 或 1 来编码，可以得到如表所示这样的定义：</p>
<p><img src="./《大话数据结构》学习之6_files/182.png" alt=""></p>
<p>将文字内容为“BADCADFEED”再次编码，对比可以看到结果串变小了。</p>
<ul>
<li>原编码二进制串：001000011010000011101100100011（共30个字符）</li>
<li>新编码二进制串：1001010010101001000111100（共25个字符）</li>
</ul>
<p>也就是说，数据被压缩了，节约了大约 17% 的存储或传输成本。随着字符的增加和多字符权重的不同，这种压缩会更加显出其优势。</p>
<p>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。例如：设有 abcd 需要编码表示（其中，a=0、b=10、c=110、d=11，则表示 110 的前缀可以是 c 或者 da，不唯一）。</p>
<p>在解码时，还要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。</p>
<p>当接收到 1001010010101001000111100 时，由约定好的赫夫曼树可知，1001 得到第一个字母是 B，接下来 01 意味着第二个字符是 A，如下图所示，其余的也相应的可以得到，从而成功解码。</p>
<p><img src="./《大话数据结构》学习之6_files/183.png" alt=""></p>
<p>一般地，设需要编码的字符集为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{d_{1},d_{2},...,d_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，各个字符在电文中出现的次数或频率集合为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{w_{1},w_{2},...,w_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">d_{1},d_{2},...,d_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作为叶子结点，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w_{1},w_{2},...,w_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p>
<h3 class="mume-header" id="613-%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE">6.13. 总结回顾</h3>

<h3 class="mume-header" id="614-%E7%BB%93%E5%B0%BE%E8%AF%AD">6.14. 结尾语</h3>

<hr>

      </div>
      
      
    
    
    
    
    
    
    
    
  </body></html>