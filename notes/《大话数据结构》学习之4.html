<!DOCTYPE html>
<!-- saved from url=(0099)file:///private/var/folders/jq/l66hzx9956qbmxs_990g1djh0000gn/T/mume2020317-90899-16ium1m.pel2.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>《大话数据结构》学习之4</title>
      
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="./《大话数据结构》学习之4_files/katex.min.css">
      
      

      
      
      
      
      
      
      

      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0">《大话数据结构》学习</h1>

<h3 class="mume-header" id="%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97">《大话数据结构》学习之四：栈与队列</h3>

<hr>
<h2 class="mume-header" id="4-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97">4. 栈与队列</h2>

<p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong></p>
<p><strong>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</strong></p>
<h3 class="mume-header" id="41-%E5%BC%80%E5%9C%BA%E7%99%BD">4.1. 开场白</h3>

<h3 class="mume-header" id="42-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89">4.2. 栈的定义</h3>

<p><strong>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</strong></p>
<p>我们把<strong>允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又被称为后进先出（LastIn First Out）的线性表，简称LIFO结构。</strong></p>
<p>理解栈的定义需要注意：</p>
<p>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。<strong>定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</strong></p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p>
<p>栈的插入操作，叫作<strong>进栈</strong>，也称<strong>压栈</strong>、<strong>入栈</strong>。如下图：</p>
<p><img src="./《大话数据结构》学习之4_files/52.png" alt=""></p>
<p>栈的删除操作，叫作<strong>出栈</strong>，也有的叫作<strong>弹栈</strong>。如下图：</p>
<p><img src="./《大话数据结构》学习之4_files/53.png" alt=""></p>
<h4 class="mume-header" id="422-%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F">4.2.2. 进栈出栈变化形式</h4>

<p>现在我要问问大家，这个最先进栈的元素，是不是就只能是最后出栈呢？</p>
<p>答案是不一定，要看什么情况。栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。</p>
<p>举例来说，如果我们现在是有 3 个整型数字元素 1、2、3 依次进栈，会有哪些出栈次序呢？</p>
<ul>
<li>
<p>第一种：1、2、3 进，再 3、2、1 出。这是最简单的最好理解的一种，出栈次序为 321。</p>
</li>
<li>
<p>第二种：1 进，1 出，2 进，2 出，3 进，3 出。也就是进一个就出一个，出栈次序为 123。</p>
</li>
<li>
<p>第三种：1 进，2 进，2 出，1 出，3 进，3 出。出栈次序为 213。</p>
</li>
<li>
<p>第四种：1 进，1 出，2 进，3 进，3 出，2 出。出栈次序为 132。</p>
</li>
<li>
<p>第五种：1 进，2 进，2 出，3 进，3 出，1 出。出栈次序为 231。</p>
</li>
</ul>
<p>有没有可能是 312 这样的次序出栈呢？答案是肯定不会。因为 3 先出栈，就意味着，3曾经进栈，既然 3 都进栈了，那也就意味着 1 和 2 已经进栈了，此时，2 一定是在 1 的上面，就是更接近栈顶，那么出栈只可能是 321，不然不满足 123 依次进栈的要求，所以此时不会发生 1 比 2 先出栈的情况。</p>
<p>从这个简单的例子就能看出，只是 3 个元素，就有 5 种可能的出栈次序，如果元素数量多，其实出栈的变化将会更多的。这个知识点一定要弄明白。</p>
<h3 class="mume-header" id="43-%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4.3. 栈的抽象数据类型</h3>

<p>对于栈来讲，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，我们改名为 push 和 pop，英文直译的话是压和弹，更容易理解。</p>
<pre data-role="codeBlock" data-info="C" class="language-c">ADT 栈（stack）
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    <span class="token function">Initstack</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>初始化操作，建立一个空栈S。
    <span class="token function">DestroyStack</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>若栈存在，则销毁它。
    <span class="token function">ClearStack</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>将栈清空。
    <span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>若栈为空，返回true<span class="token punctuation">;</span>否则返回false。
    <span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span><span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>若栈存在且非空，用e返回S的栈顶元素。
    <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>若栈S存在，插入新元素e到栈S中并成为栈顶元素。又称：进栈，压栈，入栈。
    <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">,</span><span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>删除栈S中栈顶元素，并用e返回其值。又称：出栈，弹栈。
    <span class="token function">StackLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>返回栈S的元素个数。
endADT
</pre><h3 class="mume-header" id="44-%E6%A0%88%E7%9A%84%E9%A1%BA%E8%AE%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0">4.4. 栈的顺讯存储结构及实现</h3>

<h4 class="mume-header" id="441-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">4.4.1. 栈的顺序存储结构</h4>

<p>既然栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为顺序栈。</p>
<p>线性表是用数组来实现的。下标为 0 的一端作为栈底，因为首元素都存在栈底，变化最小，若存储栈的长度为 StackSize，则栈顶位置 top 必须小于 StackSize。当栈存在一个元素时，top 等于 0，通常把空栈的判定条件定为 top 等于 −1。</p>
<p>栈的结构定义如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SElemType<span class="token punctuation">;</span>      <span class="token comment">/* SElemType类型根据实际情况而定，这里假设为int */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
    SElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                <span class="token comment">/* 用于栈顶指针 */</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>
</pre><p>栈普通情况、空栈和栈满的情况示意图(StackSize 是 5)：</p>
<p><img src="./《大话数据结构》学习之4_files/54.png" alt=""></p>
<h4 class="mume-header" id="442-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C">4.4.2. 栈的顺序存储结构——进栈操作</h4>

<p>栈的插入，即进栈操作：</p>
<p><img src="./《大话数据结构》学习之4_files/55.png" alt=""></p>
<p>对应的代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 插入元素e为新的栈顶元素 */</span>
Status <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">/* 栈满 */</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    S<span class="token operator">-&gt;</span>top<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">/* 栈顶指针增加一 */</span>
    S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>  <span class="token comment">/* 将新插入元素赋值给栈顶空间 */</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><h4 class="mume-header" id="443-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C">4.4.3. 栈的顺序存储结构——出栈操作</h4>

<p>出栈操作 pop：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，   并返回OK；否则返回ERROR */</span>
Status <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">,</span> SElemType <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token operator">*</span>e <span class="token operator">=</span> S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* 将要删除的栈顶元素赋值给e */</span>
    S<span class="token operator">-&gt;</span>top<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token comment">/* 栈顶指针减一 */</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>两者都没有涉及到任何循环语句，两者时间复杂度均是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 class="mume-header" id="45-%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4">4.5. 两栈共享空间</h3>

<p>其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在钱性表插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间束进行操作。</p>
<p>我们的做法如下图。用一个数组来存储两个栈，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 处，另一个栈为数组的末端，即下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 数组长度处。两个栈如果增加元素，就是两端点向中间延伸。</p>
<p><img src="./《大话数据结构》学习之4_files/56.png" alt=""></p>
<p>其实关键思路是：它们是在数组的两端，向中间靠拢。top1 和 top2 是栈 1 和 栈 2 的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。</p>
<p>从这里也就可以分析出来，栈 1 为空时，就是 top1 等于 -1 时；而当 top2 等于 n 时，即是栈 2 为空时，那什么时候栈满呢？</p>
<p>想想极端的情况，若栈 2 是空栈，栈 1 的 top1 等于 n—1 时，就是栈 1 满了。反之, 当栈 1 为空栈时，top2 等于 0 时，为栈 2 满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差 1 时，即 top1+1==top2 为栈满。</p>
<p>两栈共享空间的结构的代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 两栈共享空间结构 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
    SElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top1<span class="token punctuation">;</span>    <span class="token comment">/* 栈1栈顶指针 */</span>
    <span class="token keyword">int</span> top2<span class="token punctuation">;</span>    <span class="token comment">/* 栈2栈顶指针 */</span>
<span class="token punctuation">}</span> SqDoubleStack<span class="token punctuation">;</span>
</pre><p>对于两栈共享空间的 push 方法，除了要插入元素值参数外，还需要有一个判断是栈 1 还是栈 2 的栈号参数 stackNumber。插入元素的代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 插入元素e为新的栈顶元素 */</span>
Status <span class="token function">Push</span><span class="token punctuation">(</span>SqDoubleStack <span class="token operator">*</span>S<span class="token punctuation">,</span> SElemType e<span class="token punctuation">,</span> <span class="token keyword">int</span> stackNumber<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* 栈已满，不能再push新元素了 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top1 <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> S<span class="token operator">-&gt;</span>top2<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token comment">/* 栈1有元素进栈 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stackNumber <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment">/* 若栈1则先top1+1后给数组元素赋值 */</span>
        S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token operator">++</span>S<span class="token operator">-&gt;</span>top1<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token comment">/* 栈2有元素进栈 */</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stackNumber <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token comment">/* 若栈2则先top2-1后给数组元素赋值 */</span>
        S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token operator">--</span>S<span class="token operator">-&gt;</span>top2<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>因为在开始已经判断了是否有栈满的情况，所以后面的 top1+1 或 top2-1 是不担心溢出问题的。</p>
<p>对于两栈共享空间的 pop 方法，参数就只是判断栈 1 栈 2 的参数 stackNumber。代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span>
Status <span class="token function">Pop</span><span class="token punctuation">(</span>SqDoubleStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType <span class="token operator">*</span>e<span class="token punctuation">,</span><span class="token keyword">int</span> stackNumber<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>stackNumber<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top1<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">/* 说明栈1已经是空栈，溢出 */</span>
                <span class="token operator">*</span>e<span class="token operator">=</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>top1<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 将栈1的栈顶元素出栈 */</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stackNumber<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top2<span class="token operator">==</span>MAXSIZE<span class="token punctuation">)</span>
                        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">/* 说明栈2已经是空栈，溢出 */</span>
                <span class="token operator">*</span>e<span class="token operator">=</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>top2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 将栈2的栈顶元素出栈 */</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。否则，两个栈都在不停地增长，那很快就会因栈满而溢出了。</p>
<p>当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使得问题变得更复杂，要注意这个前提。</p>
<h3 class="mume-header" id="46-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0">4.6. 栈的链式存储结构及实现</h3>

<h4 class="mume-header" id="461-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">4.6.1. 栈的链式存储结构</h4>

<p>栈的链式存储结构，简称为链栈。</p>
<p>由于单链表有头指针，而栈顶指针也是必须的，所以比较好的办法是把栈顶放在单链表的头部。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。</p>
<p><img src="./《大话数据结构》学习之4_files/57.png" alt=""></p>
<p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是否溢出的问题。</p>
<p>但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是 top=NULL 的时候。</p>
<p>链栈的结构代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 链栈结构 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> StackNode
<span class="token punctuation">{</span>
        SElemType data<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> StackNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>StackNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkStackPtr<span class="token punctuation">;</span>


<span class="token keyword">typedef</span> <span class="token keyword">struct</span> LinkStack
<span class="token punctuation">{</span>
        LinkStackPtr top<span class="token punctuation">;</span>
        <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkStack<span class="token punctuation">;</span>
</pre><p>链栈的操作绝大部分都和单链表类似，只是在插入和删除上特殊一些。</p>
<h4 class="mume-header" id="462-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C">4.6.2. 栈的链式存储结构——进栈操作</h4>

<p>对于链栈的进栈 push 操作，假设元素值为 e 的新结点是 s，top 为栈顶指针。示意图如下：</p>
<p><img src="./《大话数据结构》学习之4_files/58.png" alt=""></p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 插入元素e为新的栈顶元素 */</span>
Status <span class="token function">Push</span><span class="token punctuation">(</span>LinkStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        LinkStackPtr s<span class="token operator">=</span><span class="token punctuation">(</span>LinkStackPtr<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>
        s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>    <span class="token comment">/* 把当前的栈顶元素赋值给新结点的直接后继，见图中1 */</span>
        S<span class="token operator">-&gt;</span>top<span class="token operator">=</span>s<span class="token punctuation">;</span>         <span class="token comment">/* 将新的结点s赋值给栈顶指针，见图中2 */</span>
        S<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><h4 class="mume-header" id="463-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C">4.6.3. 栈的链式存储结构——出栈操作</h4>

<p>假设变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 即可。如下图所示：</p>
<p><img src="./《大话数据结构》学习之4_files/59.png" alt=""></p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span>
Status <span class="token function">Pop</span><span class="token punctuation">(</span>LinkStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        LinkStackPtr p<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
        <span class="token operator">*</span>e<span class="token operator">=</span>S<span class="token operator">-&gt;</span>top<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        p<span class="token operator">=</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>                    <span class="token comment">/* 将栈顶结点赋值给p，见图中③ */</span>
        S<span class="token operator">-&gt;</span>top<span class="token operator">=</span>S<span class="token operator">-&gt;</span>top<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token comment">/* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* 释放结点p */</span>
        S<span class="token operator">-&gt;</span>count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>链栈的进栈 push 和出栈 pop 没有任何循环操作，时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>顺序栈与链栈：</p>
<ul>
<li>时间复杂度上均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
<li>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。</li>
<li><strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，如果它的变化在可控范围内，建议使用顺序栈。</strong></li>
</ul>
<h3 class="mume-header" id="47-%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8">4.7. 栈的作用</h3>

<p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p>
<h3 class="mume-header" id="48-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E9%80%92%E5%BD%92">4.8. 栈的应用——递归</h3>

<h4 class="mume-header" id="481-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%AE%9E%E7%8E%B0">4.8.1. 斐波那契数列实现</h4>

<p><img src="./《大话数据结构》学习之4_files/60.png" alt=""></p>
<p><img src="./《大话数据结构》学习之4_files/61.png" alt=""></p>
<p>编号 ① 的一对兔子经过六个月就变成 8 对兔子。</p>
<p>数学函数来定义就是：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">F(n)=\left\{\begin{array}{cl}
0, &amp; n=0 \\
1 &amp; n=1 \\
F(n-1)+F(n-2) &amp; n&gt;1
\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>打印出前40位的斐波那契数列数。代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span>

<span class="token keyword">int</span> <span class="token function">Fbi</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>  <span class="token comment">/* 斐波那契的递归函数 */</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">)</span>
        <span class="token keyword">return</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">Fbi</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fbi</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 这里Fbi就是函数自己，等于在调用自己 */</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"迭代显示斐波那契数列：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"递归显示斐波那契数列：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token function">Fbi</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>Fbi(i)</code> 函数当 <code>i=5</code> 的执行过程：</p>
<p><img src="./《大话数据结构》学习之4_files/62.png" alt=""></p>
<h4 class="mume-header" id="482-%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89">4.8.2. 递归定义</h4>

<p>在高级语言中，调用自己和其他函数并没有本质的不同。<strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。</strong></p>
<p>写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</strong></p>
<p>迭代和递归的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">迭代</th>
<th style="text-align:center">递归</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">循环结构</td>
<td style="text-align:center">选择结构</td>
</tr>
<tr>
<td style="text-align:center">不需要反复调用函数和占用额外的内存</td>
<td style="text-align:center">使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存</td>
</tr>
</tbody>
</table>
<p>我们应该视不同情况选择不同的代码实现方式。</p>
<p><strong>使用栈实现递归：</strong></p>
<p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
<p>当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。</p>
<h3 class="mume-header" id="49-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">4.9. 栈的应用——四则运算表达式求值</h3>

<h4 class="mume-header" id="491-%E5%90%8E%E7%BC%80%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9A%E4%B9%89">4.9.1. 后缀（逆波兰）表示法定义</h4>

<p><code>9+(3-1)×3+10÷2</code> 用后缀表示法表示：<code>9 3 1-3*+102/+</code>，叫后缀的原因在于所有的符号都是在要运算数字的后面出现。</p>
<h4 class="mume-header" id="492-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C">4.9.2. 后缀表达式计算结果</h4>

<p>后缀表达式：<code>9 3 1-3*+10 2/+</code>。</p>
<p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>
<ol>
<li>初始化一个空栈。此栈用来对要运算的数字进出使用，如下左图；</li>
<li>后缀表达式中前三个都是数字，所以 9、3、1 进栈，如下右图；</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/63.png" alt=""></p>
<ol start="3">
<li>
<p>接下来是 “-”，所以将栈中的 1 出栈作为减数，3 出栈作为被减数，并运算 3-1 得到 2，再将 2 进栈，如下左图；</p>
</li>
<li>
<p>接着是数字 3 进栈，如下右图；</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/64.png" alt=""></p>
<ol start="5">
<li>
<p>后面是 “*”，也就意味着栈中 3 和 2 出栈，2 与 3 相乘，得到 6，并将 6 进栈，如下左图；</p>
</li>
<li>
<p>下面是 “+”，所以栈中 6 和 9 出栈，9 与 6 相加，得到 15，将 1 5进栈，如图右图；</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/65.png" alt=""></p>
<ol start="7">
<li>
<p>接着是 10 与 2 两数字进栈，如下左图所示；</p>
</li>
<li>
<p>接下来是符号 “/”，因此，栈顶的 2 与 10 出栈，10 与 2 相除，得到 5，将 5 进栈，如下右图；</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/66.png" alt=""></p>
<ol start="9">
<li>
<p>最后一个是符号 “+”，所以 15 与 5 出栈并相加，得到 20，将 20 进栈，如图左图；</p>
</li>
<li>
<p>结果是 20 出栈，栈变为空，如下右图。</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/67.png" alt=""></p>
<p>果然，后缀表达法可以顺利解决计算问题。接下来需要弄清楚如何将“普通的表达式”（中缀表达式）转换为后缀表达式。</p>
<h4 class="mume-header" id="493-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.9.3. 中缀表达式转后缀表达式</h4>

<p>平时所用的标准四则运算表达式，即 <code>9+(3-1)×3+10÷2</code> 叫做中缀表达式。</p>
<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<ol>
<li>初始化一空栈，用来对符号进出栈使用，如左图；</li>
<li>第一个字符是数字 9，输出 <code>9</code>，后面是符号 “+”，进栈。如右图；</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/68.png" alt=""></p>
<ol start="3">
<li>
<p>第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈。如左图；</p>
</li>
<li>
<p>第四个字符是数字 3，输出，总表达式为 <code>9 3</code>，接着是 “-”，进栈。如右图；</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/69.png" alt=""></p>
<ol start="5">
<li>
<p>接下来是数字 1，输出，总表达式为 <code>9 3 1</code>，后面是符号“)”，此时，需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”。总的输出表达式为 <code>9 3 1 -</code>。如左图；</p>
</li>
<li>
<p>紧接着是符号 “×”，因为此时的栈顶符号为 “+” 号，优先级低于 “×”，因此不输出，“*” 进栈。接着是数字 3，输出，总的表达式为 <code>9 3 1 - 3</code>。如右图；</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/70.png" alt=""></p>
<ol start="7">
<li>
<p>之后是符号 “+”，此时当前栈顶元素 “*” 比这个 “+” 的优先级高，因此栈中元素出栈并输出（没有比 “+” 号更低的优先级，所以全部出栈），总输出表达式为 <code>9 3 1 - 3 * +</code>。然后将当前这个符号 “+” 进栈。前 6 张图的栈底的 “+” 是指中缀表达式中开头的 9 后面那个 “+”，而下图中的栈底（也是栈顶）的 “+” 是指 <code>9+(3-1)×3+</code> 中的最后一个 “+”。</p>
</li>
<li>
<p>紧接着数字 10，输出，总表达式变为 <code>9 3 1 - 3 * + 10</code>。后是符号 “÷”，所以 “/” 进栈。如右图；</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/71.png" alt=""></p>
<ol start="9">
<li>
<p>最后一个数字 2，输出，总的表达式为 <code>9 31- 3 * + 10 2</code>。如左图；</p>
</li>
<li>
<p>因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为 <code>9 3 1 - 3 * +10 2 / +</code>。如右图。</p>
</li>
</ol>
<p><img src="./《大话数据结构》学习之4_files/72.png" alt=""></p>
<p>从刚才的推导中会发现，要想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是两步：</p>
<ol>
<li>将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。</li>
<li>将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</li>
</ol>
<h3 class="mume-header" id="410-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89">4.10. 队列的定义</h3>

<p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p>
<p><strong>队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</strong> 假设队列是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q=(a_{1}, a_{2},...,a_{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就是队头元素，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是队尾元素。删除时，总是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开始，而插入时，列在最后。</p>
<p><img src="./《大话数据结构》学习之4_files/73.png" alt=""></p>
<h3 class="mume-header" id="411-%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4.11. 队列的抽象数据类型</h3>

<p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在对头进行。</p>
<pre data-role="codeBlock" data-info="C" class="language-c">ADT 队列<span class="token punctuation">(</span>Queue<span class="token punctuation">)</span>
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    <span class="token function">InitQueue</span><span class="token punctuation">(</span><span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token operator">:</span>    初始化操作，建立一个空队列Q。
    <span class="token function">DestroyQueue</span><span class="token punctuation">(</span><span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token operator">:</span> 若队列Q存在，则销毁它。
    <span class="token function">ClearQueue</span><span class="token punctuation">(</span><span class="token operator">*</span>Q<span class="token punctuation">)</span><span class="token operator">:</span>   将队列Q清空。
    <span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token operator">:</span>    若队列Q为空，返回true，否则返回false。
    <span class="token function">GetHead</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token operator">:</span>   若队列Q存在且非空，用e返回队列Q的队头元素。
    <span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">*</span>Q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token operator">:</span>   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
    <span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">*</span>Q<span class="token punctuation">,</span> <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token operator">:</span>  删除队列Q中队头元素，并用e返回其值。
    <span class="token function">QueueLength</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token operator">:</span>   返回队列Q的元素个数
endADT
</pre><h3 class="mume-header" id="412-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">4.12. 循环队列</h3>

<p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。</p>
<h4 class="mume-header" id="4121-%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3">4.12.1. 队列顺序存储的不足</h4>

<p>假设一个队列有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个元素，则顺序存储的队列需建立一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组，并把队列的所有元素存储在数组的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个单元，数组下标为 0 的一端即是队头。入队列操作就是在队尾追加一个元素，不需要移动任何元素，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p><img src="./《大话数据结构》学习之4_files/74.png" alt=""></p>
<p>队列元素的出列是在队头，即下标为 0 的位置，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为 0 的位置不为空，此时时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p><img src="./《大话数据结构》学习之4_files/75.png" alt=""></p>
<p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，引入两个指针，front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。</p>
<p>假设是长度为 5 的数组，初始状态，空队列如左图，front 与 rear 指针均指向下标为 0 的位置。然后入队 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">a_{1},a_{2},a_{3},a_{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，front 指针依然指向下标为 0 位置，而 rear 指针指向下标为 4 的位置。</p>
<p><img src="./《大话数据结构》学习之4_files/76.png" alt=""></p>
<p>出队 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_{1},a_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，front 指针指向下标为 2 的位置，rear 不变，如左图，再入队 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">a_{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，front 指针不变，rear 指针移动到数组之外。</p>
<p><img src="./《大话数据结构》学习之4_files/77.png" alt=""></p>
<p>如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，下标为 0 和 1 的地方还是空闲的,这种现象叫做<strong>假溢出</strong>。</p>
<h4 class="mume-header" id="4122-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89">4.12.2. 循环队列定义</h4>

<p>队列的这种头尾相接的顺序存储结构称为循环队列。（为了解决假溢出）</p>
<p>rear 可以改为指向下标为的位置：</p>
<p><img src="./《大话数据结构》学习之4_files/78.png" alt=""></p>
<p>接着入队 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">a_{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将它放置于下标为 0 处，rear 指针指向下标为 1 处，如左图。再入队 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">a_{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 rear 指针就与 front 指针重合，同时指向下标为 2 的位置，如右图。</p>
<p><img src="./《大话数据结构》学习之4_files/79.png" alt=""></p>
<p>如何判断此时的队列究竟是空还是满呢？</p>
<ul>
<li>办法一：设置一个标志变量 flag，当 <code>front=rear</code>，且 flag=0 时为队列空，当 <code>front=rear</code>，且 flag=1 时为队列满。</li>
<li>办法二：当队列空时，条件就是 <code>front=rear</code>，当队列满时，保留一个元素空间，如下图。也就是说，队列满时，数组中还有一个空闲单元，就认为此队列已经满了，即不允许上图右图情况出现。</li>
</ul>
<p><img src="./《大话数据结构》学习之4_files/80.png" alt=""></p>
<p>重点讨论第二种方法，由于 rear 可能比 front 大，也可能比 front 小，若队列的最大尺寸为 QueueSize，队列满的条件是：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>rear</mtext><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mtext>QueueSize</mtext><mo>=</mo><mo>=</mo><mtext>front</mtext></mrow><annotation encoding="application/x-tex">(\text {rear}+1) \% \text {Queue} \text {Size}==\text {front}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">rear</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">%</span><span class="mord text"><span class="mord">Queue</span></span><span class="mord text"><span class="mord">Size</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">front</span></span></span></span></span></span></p>
<p>（取模 “%” 的目的就是为了整合 rear 与 front 大小为一个问题）。</p>
<p><img src="./《大话数据结构》学习之4_files/81.png" alt=""></p>
<p>循环队列的顺序存储结构代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 循环队列的顺序存储结构 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
    QElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front<span class="token punctuation">;</span>      <span class="token comment">/* 头指针 */</span>
    <span class="token keyword">int</span> rear<span class="token punctuation">;</span>       <span class="token comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>
</pre><p>循环队列的初始化代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 初始化一个空队列Q */</span>
Status <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Q<span class="token operator">-&gt;</span>front<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    Q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span>  OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>循环队列求队列长度代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span>
<span class="token keyword">int</span> <span class="token function">QueueLength</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span>  <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span>MAXSIZE<span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>循环队列的入队列操作代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span>
Status <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q<span class="token punctuation">,</span>QElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE <span class="token operator">==</span> Q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span>    <span class="token comment">/* 队列满的判断 */</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    Q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>         <span class="token comment">/* 将元素e赋值给队尾 */</span>
    Q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span><span class="token comment">/* rear指针向后移一位置， */</span>
                                <span class="token comment">/* 若到最后则转到数组头部 */</span>
    <span class="token keyword">return</span>  OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>循环队列的出队列操作代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span>
Status <span class="token function">DeQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q<span class="token punctuation">,</span>QElemType <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>            <span class="token comment">/* 队列空的判断 */</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token operator">*</span>e<span class="token operator">=</span>Q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>Q<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment">/* 将队头元素赋值给e */</span>
    Q<span class="token operator">-&gt;</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span>  <span class="token comment">/* front指针向后移一位置， */</span>
                                    <span class="token comment">/* 若到最后则转到数组头部 */</span>
    <span class="token keyword">return</span>  OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>从上述的内容可以发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以还需要研究下不需要担心队列长度的链式存储结构。</p>
<h3 class="mume-header" id="413-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0">4.13. 队列的链式存储结构及实现</h3>

<p><strong>队列的链式存储结构就是线性表的单链表，只不过它只能尾进头出，简称为链队列。</strong></p>
<p>将队头指针指向链队列的头结点，队尾指针指向终端结点：</p>
<p><img src="./《大话数据结构》学习之4_files/82.png" alt=""></p>
<p>空队列时，front 和 rear 都指向头结点：</p>
<p><img src="./《大话数据结构》学习之4_files/83.png" alt=""></p>
<p>链队列的结构为：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* QElemType类型根据实际情况而定，这里假设为int */</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> QElemType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> QNode    <span class="token comment">/* 结点结构 */</span>
<span class="token punctuation">{</span>
    QElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> QNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> QNode<span class="token punctuation">,</span><span class="token operator">*</span>QueuePtr<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>          <span class="token comment">/* 队列的链表结构 */</span>
<span class="token punctuation">{</span>
    QueuePtr front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span> <span class="token comment">/* 队头、队尾指针 */</span>
<span class="token punctuation">}</span> LinkQueue<span class="token punctuation">;</span>
</pre><h4 class="mume-header" id="4131-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C">4.13.1. 队列的链式存储结构——入队操作</h4>

<p>入队操作时就是在链表尾部插入结点：</p>
<p><img src="./《大话数据结构》学习之4_files/84.png" alt=""></p>
<p>代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 插入元素e为Q的新的队尾元素 */</span>
Status <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">*</span>Q<span class="token punctuation">,</span>QElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    QueuePtr s<span class="token operator">=</span><span class="token punctuation">(</span>QueuePtr<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token comment">/* 存储分配失败 */</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    Q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>    <span class="token comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中1 */</span>
    Q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span>s<span class="token punctuation">;</span>      <span class="token comment">/* 把当前的s设置为队尾结点，rear指向s，见图中2 */</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><h4 class="mume-header" id="4132-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C">4.13.2. 队列的链式存储结构——出队操作</h4>

<p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将 rear 指向头结点。</p>
<p><img src="./《大话数据结构》学习之4_files/85.png" alt=""></p>
<p>代码如下：</p>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span>
Status <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">*</span>Q<span class="token punctuation">,</span>QElemType <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    QueuePtr p<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>front<span class="token operator">==</span>Q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    p<span class="token operator">=</span>Q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>       <span class="token comment">/* 将欲删除的队头结点暂存给p，见图中1 */</span>
    <span class="token operator">*</span>e<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>             <span class="token comment">/* 将欲删除的队头结点的值赋值给e */</span>
    Q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中2 */</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token operator">-&gt;</span>rear<span class="token operator">==</span>p<span class="token punctuation">)</span>      <span class="token comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中3 */</span>
        Q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span>Q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>循环队列与链队列：</p>
<ul>
<li>时间上，基本操作都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。</li>
<li>空间上，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。</li>
<li>在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列。</li>
</ul>
<h3 class="mume-header" id="414-%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE">4.14. 总结回顾</h3>

<p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p>
<p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。</p>
<ul>
<li>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</li>
<li>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
<li>都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</li>
</ul>
<p><img src="./《大话数据结构》学习之4_files/86.png" alt=""></p>
<h3 class="mume-header" id="415-%E7%BB%93%E5%B0%BE%E8%AF%AD">4.15. 结尾语</h3>

<hr>

      </div>
      
      
    
    
    
    
    
    
    
    
  </body></html>